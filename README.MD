ğŸš€ Project Overview

This project demonstrates how HMAC ensures message integrity and authenticity between a Sender and Receiver, even when an attacker (Mallory) intercepts the message.

The implementation includes:

Pure Python SHA-256 implementation

HMAC construction using ipad (0x36) and opad (0x5C)

Sender â†’ Mallory â†’ Receiver communication flow

Integrity verification using shared secret key

Tampering detection using computed HMAC comparison
----------------------------------------------------------------------------------------------------------------

ğŸ“‚ Project Structure

Src/
 Src/
 â”œâ”€â”€ code/
 â”‚    â”œâ”€â”€ hmac_sha256.py
 â”‚    â”œâ”€â”€ sender.py
 â”‚    â”œâ”€â”€ receiver.py
 â”‚    â”œâ”€â”€ mallory.py
 â”‚    â””â”€â”€ shared_pipe.py
 â”œâ”€â”€ logs/
 â”‚    â”œâ”€â”€ sender_hmac.txt
 â”‚    â”œâ”€â”€ sender_to_mallory.txt
 â”‚    â””â”€â”€ mallory_to_receiver.txt
 â””â”€â”€ PPT/
      â””â”€â”€ HMAC_Presentation.pptx


ğŸ“Œ HMAC-SHA256 From Scratch â€” Secure Message Authentication System

A complete from-scratch implementation of:

âœ” SHA-256 hashing
âœ” HMAC (Hash-based Message Authentication Code)
âœ” Message integrity verification
âœ” Demonstration of sender, attacker (Mallory), and receiver workflow

This project shows how secure message authentication works without using any external cryptographic libraries - everything is implemented manually using Python.
-----------------------------------------------------------------------------------------------------------------------

ğŸ§  Core Features
ğŸ” 1. SHA-256 From Scratch

Implements message padding

64-round compression function

32-bit word operations

Right rotation, bitwise operations

Follows FIPS-180-4 structure

ğŸ”‘ 2. HMAC-SHA256 Implementation

Block size = 64 bytes

Key normalization (shortened or padded)

ipad = 0x36, opad = 0x5C

HMAC = SHA256(opad || SHA256(ipad || message))

ğŸ“¬ 3. Three-Party Message Flow
| Party        | Role                             |
| ------------ | -------------------------------- |
| **Sender**   | Creates message + HMAC           |
| **Mallory**  | Intercepts & optionally tampers  |
| **Receiver** | Computes HMAC & checks integrity |


ğŸ” 4. Message Tampering Detection

Receiver recomputes HMAC â†’ if mismatch â†’ message was modified.
------------------------------------------------------------------------------------------------------------------------

ğŸ›  How It Works
Sender --(Message + HMAC)--> Mallory --(Message*)--> Receiver

Steps:

1. Sender

Inputs a message

Computes:

SHA-256(message)

HMAC(key, message)

Writes data to shared files

2. Mallory (Attacker)

Reads message

Optionally modifies it

Forwards it to Receiver

3. Receiver

Reads message and senderâ€™s HMAC

Computes its own HMAC

Compares â†’ Match = Authentic / No Match = Tampered
----------------------------------------------------------------------------------------------------------------
â–¶ï¸ Running the Application

Run each script in separate terminals:

Terminal 1 â€” Sender
py sender.py
Enter a message â†’ it generates hash + HMAC.

Terminal 2 â€” Mallory
py mallory.py
You can tamper with the message.

Terminal 3 â€” Receiver
py receiver.py
Receiver verifies:

Computed HMAC

Senderâ€™s HMAC

Reports True/False
----------------------------------------------------------------------------------------------------------------
ğŸ“˜ Source Code Summary
ğŸ”¹ hmac_sha256.py

Contains your full implementation:

sha256() â€” hashing function

right_rotate() â€” rotates 32-bit words

hmac_hash() â€” HMAC construction

sender_process() â€” used by sender.py

ğŸ”¹ sender.py

Takes user input

Computes SHA-256 + HMAC

Stores message & HMAC in shared files

ğŸ”¹ mallory.py

Acts as an attacker

Intercepts original message

Allows tampering

Forwards final message

ğŸ”¹ receiver.py

Reads tampered/original message

Computes HMAC

Compares with senderâ€™s HMAC

Detects tampering
--------------------------------------------------------------------------------------------------------
ğŸ” Security Properties Achieved

âœ” Integrity â€” receiver detects modified messages
âœ” Authentication â€” only sender with key can generate valid HMAC
âœ” Keyed Hashing â€” prevents brute-force hash forgery
-----------------------------------------------------------------------------------------------------------
ğŸ§© Why This Project Matters

This project helps you understand:

How real systems like TLS, JWT, AWS Signature V4, OAuth, API authentication use HMAC

Why raw hashing cannot authenticate messages

How an attacker fails to forge the correct HMAC

It is a perfect demonstration for networking, security, or cryptography assignments.

